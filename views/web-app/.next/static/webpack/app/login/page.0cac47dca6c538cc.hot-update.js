"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   auth: function() { return /* binding */ auth; },\n/* harmony export */   chat: function() { return /* binding */ chat; },\n/* harmony export */   transcription: function() { return /* binding */ transcription; },\n/* harmony export */   tts: function() { return /* binding */ tts; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ \"(app-pages-browser)/./src/lib/logger.ts\");\n/**\r\n * API Client for Little Monster Backend\r\n * Connects to API Gateway at http://localhost\r\n */ \n\nconst API_URL = \"http://localhost\" || 0;\n_logger__WEBPACK_IMPORTED_MODULE_0__.logger.info(\"API\", \"API Client initializing\", {\n    baseURL: API_URL\n});\nconst api = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n    baseURL: API_URL,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\n// Request interceptor to add JWT token\napi.interceptors.request.use((config)=>{\n    var _config_url;\n    // Don't add token for auth endpoints\n    if ((_config_url = config.url) === null || _config_url === void 0 ? void 0 : _config_url.includes(\"/api/auth/\")) {\n        return config;\n    }\n    // Get token from localStorage\n    if (true) {\n        const token = localStorage.getItem(\"access_token\");\n        if (token) {\n            config.headers.Authorization = \"Bearer \".concat(token);\n        }\n    }\n    return config;\n}, (error)=>{\n    return Promise.reject(error);\n});\n// Response interceptor to handle token refresh\napi.interceptors.response.use((response)=>response, async (error)=>{\n    var _error_response;\n    const originalRequest = error.config;\n    // If 401 and not already retrying, try to refresh token\n    if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 401 && !originalRequest._retry) {\n        originalRequest._retry = true;\n        if (true) {\n            const refreshToken = localStorage.getItem(\"refresh_token\");\n            if (refreshToken) {\n                try {\n                    const response = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(\"\".concat(API_URL, \"/api/auth/refresh\"), {\n                        refresh_token: refreshToken\n                    });\n                    const { access_token } = response.data;\n                    localStorage.setItem(\"access_token\", access_token);\n                    // Retry original request with new token\n                    originalRequest.headers.Authorization = \"Bearer \".concat(access_token);\n                    return (0,axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(originalRequest);\n                } catch (refreshError) {\n                    // Refresh failed, clear tokens and redirect to login\n                    localStorage.removeItem(\"access_token\");\n                    localStorage.removeItem(\"refresh_token\");\n                    localStorage.removeItem(\"user\");\n                    if (true) {\n                        window.location.href = \"/login\";\n                    }\n                    return Promise.reject(refreshError);\n                }\n            }\n        }\n    }\n    return Promise.reject(error);\n});\n// Auth API\nconst auth = {\n    register: (email, password, username)=>api.post(\"/api/auth/register\", {\n            email,\n            password,\n            username\n        }),\n    login: (email, password)=>api.post(\"/api/auth/login\", {\n            email,\n            password\n        }),\n    logout: (refreshToken)=>api.post(\"/api/auth/logout\", {\n            refresh_token: refreshToken\n        }),\n    refresh: (refreshToken)=>api.post(\"/api/auth/refresh\", {\n            refresh_token: refreshToken\n        })\n};\n// Chat API\nconst chat = {\n    sendMessage: function(message, conversationId) {\n        let useRag = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        return api.post(\"/api/chat/message\", {\n            message,\n            conversation_id: conversationId,\n            use_rag: useRag\n        });\n    },\n    getConversations: ()=>api.get(\"/api/chat/conversations\"),\n    uploadMaterial: (title, content, subject)=>api.post(\"/api/chat/materials\", {\n            title,\n            content,\n            subject\n        })\n};\n// Transcription API\nconst transcription = {\n    upload: function(file) {\n        let language = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"en\";\n        const formData = new FormData();\n        formData.append(\"file\", file);\n        formData.append(\"language\", language);\n        return api.post(\"/api/transcribe/\", formData, {\n            headers: {\n                \"Content-Type\": \"multipart/form-data\"\n            }\n        });\n    },\n    getJobStatus: (jobId)=>api.get(\"/api/transcribe/jobs/\".concat(jobId)),\n    getResult: (jobId)=>api.get(\"/api/transcribe/results/\".concat(jobId))\n};\n// TTS API\nconst tts = {\n    generate: (text, voice)=>api.post(\"/api/tts/generate\", {\n            text,\n            voice\n        })\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (api);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUN5QjtBQUNRO0FBRWxDLE1BQU1FLFVBQVVDLGtCQUErQixJQUFJO0FBRW5ERiwyQ0FBTUEsQ0FBQ0ssSUFBSSxDQUFDLE9BQU8sMkJBQTJCO0lBQUVDLFNBQVNMO0FBQVE7QUFFakUsTUFBTU0sTUFBTVIsNkNBQUtBLENBQUNTLE1BQU0sQ0FBQztJQUN2QkYsU0FBU0w7SUFDVFEsU0FBUztRQUNQLGdCQUFnQjtJQUNsQjtBQUNGO0FBRUEsdUNBQXVDO0FBQ3ZDRixJQUFJRyxZQUFZLENBQUNDLE9BQU8sQ0FBQ0MsR0FBRyxDQUMxQixDQUFDQztRQUVLQTtJQURKLHFDQUFxQztJQUNyQyxLQUFJQSxjQUFBQSxPQUFPQyxHQUFHLGNBQVZELGtDQUFBQSxZQUFZRSxRQUFRLENBQUMsZUFBZTtRQUN0QyxPQUFPRjtJQUNUO0lBRUEsOEJBQThCO0lBQzlCLElBQUksSUFBa0IsRUFBYTtRQUNqQyxNQUFNRyxRQUFRQyxhQUFhQyxPQUFPLENBQUM7UUFDbkMsSUFBSUYsT0FBTztZQUNUSCxPQUFPSixPQUFPLENBQUNVLGFBQWEsR0FBRyxVQUFnQixPQUFOSDtRQUMzQztJQUNGO0lBRUEsT0FBT0g7QUFDVCxHQUNBLENBQUNPO0lBQ0MsT0FBT0MsUUFBUUMsTUFBTSxDQUFDRjtBQUN4QjtBQUdGLCtDQUErQztBQUMvQ2IsSUFBSUcsWUFBWSxDQUFDYSxRQUFRLENBQUNYLEdBQUcsQ0FDM0IsQ0FBQ1csV0FBYUEsVUFDZCxPQUFPSDtRQUlEQTtJQUhKLE1BQU1JLGtCQUFrQkosTUFBTVAsTUFBTTtJQUVwQyx3REFBd0Q7SUFDeEQsSUFBSU8sRUFBQUEsa0JBQUFBLE1BQU1HLFFBQVEsY0FBZEgsc0NBQUFBLGdCQUFnQkssTUFBTSxNQUFLLE9BQU8sQ0FBQ0QsZ0JBQWdCRSxNQUFNLEVBQUU7UUFDN0RGLGdCQUFnQkUsTUFBTSxHQUFHO1FBRXpCLElBQUksSUFBa0IsRUFBYTtZQUNqQyxNQUFNQyxlQUFlVixhQUFhQyxPQUFPLENBQUM7WUFFMUMsSUFBSVMsY0FBYztnQkFDaEIsSUFBSTtvQkFDRixNQUFNSixXQUFXLE1BQU14Qiw2Q0FBS0EsQ0FBQzZCLElBQUksQ0FBQyxHQUFXLE9BQVIzQixTQUFRLHNCQUFvQjt3QkFDL0Q0QixlQUFlRjtvQkFDakI7b0JBRUEsTUFBTSxFQUFFRyxZQUFZLEVBQUUsR0FBR1AsU0FBU1EsSUFBSTtvQkFDdENkLGFBQWFlLE9BQU8sQ0FBQyxnQkFBZ0JGO29CQUVyQyx3Q0FBd0M7b0JBQ3hDTixnQkFBZ0JmLE9BQU8sQ0FBQ1UsYUFBYSxHQUFHLFVBQXVCLE9BQWJXO29CQUNsRCxPQUFPL0IsaURBQUtBLENBQUN5QjtnQkFDZixFQUFFLE9BQU9TLGNBQWM7b0JBQ3JCLHFEQUFxRDtvQkFDckRoQixhQUFhaUIsVUFBVSxDQUFDO29CQUN4QmpCLGFBQWFpQixVQUFVLENBQUM7b0JBQ3hCakIsYUFBYWlCLFVBQVUsQ0FBQztvQkFDeEIsSUFBSSxJQUFrQixFQUFhO3dCQUNqQ0MsT0FBT0MsUUFBUSxDQUFDQyxJQUFJLEdBQUc7b0JBQ3pCO29CQUNBLE9BQU9oQixRQUFRQyxNQUFNLENBQUNXO2dCQUN4QjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLE9BQU9aLFFBQVFDLE1BQU0sQ0FBQ0Y7QUFDeEI7QUFHRixXQUFXO0FBQ0osTUFBTWtCLE9BQU87SUFDbEJDLFVBQVUsQ0FBQ0MsT0FBZUMsVUFBa0JDLFdBQzFDbkMsSUFBSXFCLElBQUksQ0FBQyxzQkFBc0I7WUFBRVk7WUFBT0M7WUFBVUM7UUFBUztJQUU3REMsT0FBTyxDQUFDSCxPQUFlQyxXQUNyQmxDLElBQUlxQixJQUFJLENBQUMsbUJBQW1CO1lBQUVZO1lBQU9DO1FBQVM7SUFFaERHLFFBQVEsQ0FBQ2pCLGVBQ1BwQixJQUFJcUIsSUFBSSxDQUFDLG9CQUFvQjtZQUFFQyxlQUFlRjtRQUFhO0lBRTdEa0IsU0FBUyxDQUFDbEIsZUFDUnBCLElBQUlxQixJQUFJLENBQUMscUJBQXFCO1lBQUVDLGVBQWVGO1FBQWE7QUFDaEUsRUFBRTtBQUVGLFdBQVc7QUFDSixNQUFNbUIsT0FBTztJQUNsQkMsYUFBYSxTQUFDQyxTQUFpQkM7WUFBeUJDLDBFQUFrQjtlQUN4RTNDLElBQUlxQixJQUFJLENBQUMscUJBQXFCO1lBQUVvQjtZQUFTRyxpQkFBaUJGO1lBQWdCRyxTQUFTRjtRQUFPOztJQUU1Rkcsa0JBQWtCLElBQ2hCOUMsSUFBSStDLEdBQUcsQ0FBQztJQUVWQyxnQkFBZ0IsQ0FBQ0MsT0FBZUMsU0FBaUJDLFVBQy9DbkQsSUFBSXFCLElBQUksQ0FBQyx1QkFBdUI7WUFBRTRCO1lBQU9DO1lBQVNDO1FBQVE7QUFDOUQsRUFBRTtBQUVGLG9CQUFvQjtBQUNiLE1BQU1DLGdCQUFnQjtJQUMzQkMsUUFBUSxTQUFDQztZQUFZQyw0RUFBbUI7UUFDdEMsTUFBTUMsV0FBVyxJQUFJQztRQUNyQkQsU0FBU0UsTUFBTSxDQUFDLFFBQVFKO1FBQ3hCRSxTQUFTRSxNQUFNLENBQUMsWUFBWUg7UUFDNUIsT0FBT3ZELElBQUlxQixJQUFJLENBQUMsb0JBQW9CbUMsVUFBVTtZQUM1Q3RELFNBQVM7Z0JBQUUsZ0JBQWdCO1lBQXNCO1FBQ25EO0lBQ0Y7SUFFQXlELGNBQWMsQ0FBQ0MsUUFDYjVELElBQUkrQyxHQUFHLENBQUMsd0JBQThCLE9BQU5hO0lBRWxDQyxXQUFXLENBQUNELFFBQ1Y1RCxJQUFJK0MsR0FBRyxDQUFDLDJCQUFpQyxPQUFOYTtBQUN2QyxFQUFFO0FBRUYsVUFBVTtBQUNILE1BQU1FLE1BQU07SUFDakJDLFVBQVUsQ0FBQ0MsTUFBY0MsUUFDdkJqRSxJQUFJcUIsSUFBSSxDQUFDLHFCQUFxQjtZQUFFMkM7WUFBTUM7UUFBTTtBQUNoRCxFQUFFO0FBRUYsK0RBQWVqRSxHQUFHQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYXBpLnRzPzJmYWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEFQSSBDbGllbnQgZm9yIExpdHRsZSBNb25zdGVyIEJhY2tlbmRcclxuICogQ29ubmVjdHMgdG8gQVBJIEdhdGV3YXkgYXQgaHR0cDovL2xvY2FsaG9zdFxyXG4gKi9cclxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInO1xyXG5cclxuY29uc3QgQVBJX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3QnO1xyXG5cclxubG9nZ2VyLmluZm8oJ0FQSScsICdBUEkgQ2xpZW50IGluaXRpYWxpemluZycsIHsgYmFzZVVSTDogQVBJX1VSTCB9KTtcclxuXHJcbmNvbnN0IGFwaSA9IGF4aW9zLmNyZWF0ZSh7XHJcbiAgYmFzZVVSTDogQVBJX1VSTCxcclxuICBoZWFkZXJzOiB7XHJcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gIH0sXHJcbn0pO1xyXG5cclxuLy8gUmVxdWVzdCBpbnRlcmNlcHRvciB0byBhZGQgSldUIHRva2VuXHJcbmFwaS5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoXHJcbiAgKGNvbmZpZykgPT4ge1xyXG4gICAgLy8gRG9uJ3QgYWRkIHRva2VuIGZvciBhdXRoIGVuZHBvaW50c1xyXG4gICAgaWYgKGNvbmZpZy51cmw/LmluY2x1ZGVzKCcvYXBpL2F1dGgvJykpIHtcclxuICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gR2V0IHRva2VuIGZyb20gbG9jYWxTdG9yYWdlXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWNjZXNzX3Rva2VuJyk7XHJcbiAgICAgIGlmICh0b2tlbikge1xyXG4gICAgICAgIGNvbmZpZy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gY29uZmlnO1xyXG4gIH0sXHJcbiAgKGVycm9yKSA9PiB7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gIH1cclxuKTtcclxuXHJcbi8vIFJlc3BvbnNlIGludGVyY2VwdG9yIHRvIGhhbmRsZSB0b2tlbiByZWZyZXNoXHJcbmFwaS5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKFxyXG4gIChyZXNwb25zZSkgPT4gcmVzcG9uc2UsXHJcbiAgYXN5bmMgKGVycm9yKSA9PiB7XHJcbiAgICBjb25zdCBvcmlnaW5hbFJlcXVlc3QgPSBlcnJvci5jb25maWc7XHJcbiAgICBcclxuICAgIC8vIElmIDQwMSBhbmQgbm90IGFscmVhZHkgcmV0cnlpbmcsIHRyeSB0byByZWZyZXNoIHRva2VuXHJcbiAgICBpZiAoZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNDAxICYmICFvcmlnaW5hbFJlcXVlc3QuX3JldHJ5KSB7XHJcbiAgICAgIG9yaWdpbmFsUmVxdWVzdC5fcmV0cnkgPSB0cnVlO1xyXG4gICAgICBcclxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgY29uc3QgcmVmcmVzaFRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3JlZnJlc2hfdG9rZW4nKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAocmVmcmVzaFRva2VuKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7QVBJX1VSTH0vYXBpL2F1dGgvcmVmcmVzaGAsIHtcclxuICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgeyBhY2Nlc3NfdG9rZW4gfSA9IHJlc3BvbnNlLmRhdGE7XHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhY2Nlc3NfdG9rZW4nLCBhY2Nlc3NfdG9rZW4pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gUmV0cnkgb3JpZ2luYWwgcmVxdWVzdCB3aXRoIG5ldyB0b2tlblxyXG4gICAgICAgICAgICBvcmlnaW5hbFJlcXVlc3QuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke2FjY2Vzc190b2tlbn1gO1xyXG4gICAgICAgICAgICByZXR1cm4gYXhpb3Mob3JpZ2luYWxSZXF1ZXN0KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKHJlZnJlc2hFcnJvcikge1xyXG4gICAgICAgICAgICAvLyBSZWZyZXNoIGZhaWxlZCwgY2xlYXIgdG9rZW5zIGFuZCByZWRpcmVjdCB0byBsb2dpblxyXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYWNjZXNzX3Rva2VuJyk7XHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdyZWZyZXNoX3Rva2VuJyk7XHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd1c2VyJyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy9sb2dpbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlZnJlc2hFcnJvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiAgfVxyXG4pO1xyXG5cclxuLy8gQXV0aCBBUElcclxuZXhwb3J0IGNvbnN0IGF1dGggPSB7XHJcbiAgcmVnaXN0ZXI6IChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nLCB1c2VybmFtZT86IHN0cmluZykgPT5cclxuICAgIGFwaS5wb3N0KCcvYXBpL2F1dGgvcmVnaXN0ZXInLCB7IGVtYWlsLCBwYXNzd29yZCwgdXNlcm5hbWUgfSksXHJcbiAgXHJcbiAgbG9naW46IChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PlxyXG4gICAgYXBpLnBvc3QoJy9hcGkvYXV0aC9sb2dpbicsIHsgZW1haWwsIHBhc3N3b3JkIH0pLFxyXG4gIFxyXG4gIGxvZ291dDogKHJlZnJlc2hUb2tlbjogc3RyaW5nKSA9PlxyXG4gICAgYXBpLnBvc3QoJy9hcGkvYXV0aC9sb2dvdXQnLCB7IHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbiB9KSxcclxuICBcclxuICByZWZyZXNoOiAocmVmcmVzaFRva2VuOiBzdHJpbmcpID0+XHJcbiAgICBhcGkucG9zdCgnL2FwaS9hdXRoL3JlZnJlc2gnLCB7IHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbiB9KSxcclxufTtcclxuXHJcbi8vIENoYXQgQVBJXHJcbmV4cG9ydCBjb25zdCBjaGF0ID0ge1xyXG4gIHNlbmRNZXNzYWdlOiAobWVzc2FnZTogc3RyaW5nLCBjb252ZXJzYXRpb25JZD86IG51bWJlciwgdXNlUmFnOiBib29sZWFuID0gdHJ1ZSkgPT5cclxuICAgIGFwaS5wb3N0KCcvYXBpL2NoYXQvbWVzc2FnZScsIHsgbWVzc2FnZSwgY29udmVyc2F0aW9uX2lkOiBjb252ZXJzYXRpb25JZCwgdXNlX3JhZzogdXNlUmFnIH0pLFxyXG4gIFxyXG4gIGdldENvbnZlcnNhdGlvbnM6ICgpID0+XHJcbiAgICBhcGkuZ2V0KCcvYXBpL2NoYXQvY29udmVyc2F0aW9ucycpLFxyXG4gIFxyXG4gIHVwbG9hZE1hdGVyaWFsOiAodGl0bGU6IHN0cmluZywgY29udGVudDogc3RyaW5nLCBzdWJqZWN0Pzogc3RyaW5nKSA9PlxyXG4gICAgYXBpLnBvc3QoJy9hcGkvY2hhdC9tYXRlcmlhbHMnLCB7IHRpdGxlLCBjb250ZW50LCBzdWJqZWN0IH0pLFxyXG59O1xyXG5cclxuLy8gVHJhbnNjcmlwdGlvbiBBUElcclxuZXhwb3J0IGNvbnN0IHRyYW5zY3JpcHRpb24gPSB7XHJcbiAgdXBsb2FkOiAoZmlsZTogRmlsZSwgbGFuZ3VhZ2U6IHN0cmluZyA9ICdlbicpID0+IHtcclxuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBmaWxlKTtcclxuICAgIGZvcm1EYXRhLmFwcGVuZCgnbGFuZ3VhZ2UnLCBsYW5ndWFnZSk7XHJcbiAgICByZXR1cm4gYXBpLnBvc3QoJy9hcGkvdHJhbnNjcmliZS8nLCBmb3JtRGF0YSwge1xyXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScgfSxcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgXHJcbiAgZ2V0Sm9iU3RhdHVzOiAoam9iSWQ6IG51bWJlcikgPT5cclxuICAgIGFwaS5nZXQoYC9hcGkvdHJhbnNjcmliZS9qb2JzLyR7am9iSWR9YCksXHJcbiAgXHJcbiAgZ2V0UmVzdWx0OiAoam9iSWQ6IG51bWJlcikgPT5cclxuICAgIGFwaS5nZXQoYC9hcGkvdHJhbnNjcmliZS9yZXN1bHRzLyR7am9iSWR9YCksXHJcbn07XHJcblxyXG4vLyBUVFMgQVBJXHJcbmV4cG9ydCBjb25zdCB0dHMgPSB7XHJcbiAgZ2VuZXJhdGU6ICh0ZXh0OiBzdHJpbmcsIHZvaWNlPzogc3RyaW5nKSA9PlxyXG4gICAgYXBpLnBvc3QoJy9hcGkvdHRzL2dlbmVyYXRlJywgeyB0ZXh0LCB2b2ljZSB9KSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFwaTtcclxuIl0sIm5hbWVzIjpbImF4aW9zIiwibG9nZ2VyIiwiQVBJX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiaW5mbyIsImJhc2VVUkwiLCJhcGkiLCJjcmVhdGUiLCJoZWFkZXJzIiwiaW50ZXJjZXB0b3JzIiwicmVxdWVzdCIsInVzZSIsImNvbmZpZyIsInVybCIsImluY2x1ZGVzIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiQXV0aG9yaXphdGlvbiIsImVycm9yIiwiUHJvbWlzZSIsInJlamVjdCIsInJlc3BvbnNlIiwib3JpZ2luYWxSZXF1ZXN0Iiwic3RhdHVzIiwiX3JldHJ5IiwicmVmcmVzaFRva2VuIiwicG9zdCIsInJlZnJlc2hfdG9rZW4iLCJhY2Nlc3NfdG9rZW4iLCJkYXRhIiwic2V0SXRlbSIsInJlZnJlc2hFcnJvciIsInJlbW92ZUl0ZW0iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJhdXRoIiwicmVnaXN0ZXIiLCJlbWFpbCIsInBhc3N3b3JkIiwidXNlcm5hbWUiLCJsb2dpbiIsImxvZ291dCIsInJlZnJlc2giLCJjaGF0Iiwic2VuZE1lc3NhZ2UiLCJtZXNzYWdlIiwiY29udmVyc2F0aW9uSWQiLCJ1c2VSYWciLCJjb252ZXJzYXRpb25faWQiLCJ1c2VfcmFnIiwiZ2V0Q29udmVyc2F0aW9ucyIsImdldCIsInVwbG9hZE1hdGVyaWFsIiwidGl0bGUiLCJjb250ZW50Iiwic3ViamVjdCIsInRyYW5zY3JpcHRpb24iLCJ1cGxvYWQiLCJmaWxlIiwibGFuZ3VhZ2UiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwiZ2V0Sm9iU3RhdHVzIiwiam9iSWQiLCJnZXRSZXN1bHQiLCJ0dHMiLCJnZW5lcmF0ZSIsInRleHQiLCJ2b2ljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/logger.ts":
/*!***************************!*\
  !*** ./src/lib/logger.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   logger: function() { return /* binding */ logger; }\n/* harmony export */ });\n/**\r\n * Frontend Logger Utility\r\n * Logs to console AND saves to localStorage for debugging\r\n * Provides verbose logging for all UI operations\r\n */ class Logger {\n    log(level, category, message, data) {\n        const entry = {\n            timestamp: new Date().toISOString(),\n            level,\n            category,\n            message,\n            data\n        };\n        // Console output with color\n        const colors = {\n            DEBUG: \"\\x1b[36m\",\n            INFO: \"\\x1b[32m\",\n            WARN: \"\\x1b[33m\",\n            ERROR: \"\\x1b[31m\" // Red\n        };\n        const reset = \"\\x1b[0m\";\n        console.log(\"\".concat(colors[level], \"[\").concat(level, \"]\").concat(reset, \" [\").concat(category, \"] \").concat(message), data ? data : \"\");\n        // Save to localStorage\n        if (true) {\n            try {\n                const logs = this.getLogs();\n                logs.push(entry);\n                // Keep only last N logs\n                if (logs.length > this.maxLogs) {\n                    logs.shift();\n                }\n                localStorage.setItem(this.logKey, JSON.stringify(logs));\n            } catch (error) {\n                console.error(\"Failed to save log:\", error);\n            }\n        }\n    }\n    debug(category, message, data) {\n        this.log(\"DEBUG\", category, message, data);\n    }\n    info(category, message, data) {\n        this.log(\"INFO\", category, message, data);\n    }\n    warn(category, message, data) {\n        this.log(\"WARN\", category, message, data);\n    }\n    error(category, message, data) {\n        this.log(\"ERROR\", category, message, data);\n    }\n    // Get all logs from localStorage\n    getLogs() {\n        if (false) {}\n        try {\n            const logsJson = localStorage.getItem(this.logKey);\n            return logsJson ? JSON.parse(logsJson) : [];\n        } catch (error) {\n            console.error(\"Failed to get logs:\", error);\n            return [];\n        }\n    }\n    // Clear all logs\n    clearLogs() {\n        if (true) {\n            localStorage.removeItem(this.logKey);\n        }\n    }\n    // Download logs as file\n    downloadLogs() {\n        const logs = this.getLogs();\n        const logText = logs.map((entry)=>\"[\".concat(entry.timestamp, \"] [\").concat(entry.level, \"] [\").concat(entry.category, \"] \").concat(entry.message).concat(entry.data ? \"\\n  Data: \" + JSON.stringify(entry.data, null, 2) : \"\")).join(\"\\n\\n\");\n        const blob = new Blob([\n            logText\n        ], {\n            type: \"text/plain\"\n        });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.href = url;\n        a.download = \"lm-ui-logs-\".concat(new Date().toISOString().split(\"T\")[0], \".txt\");\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n    // Get logs summary\n    getSummary() {\n        const logs = this.getLogs();\n        return {\n            total: logs.length,\n            errors: logs.filter((l)=>l.level === \"ERROR\").length,\n            warns: logs.filter((l)=>l.level === \"WARN\").length,\n            info: logs.filter((l)=>l.level === \"INFO\").length,\n            debug: logs.filter((l)=>l.level === \"DEBUG\").length,\n            latest: logs.slice(-10).reverse() // Last 10 logs\n        };\n    }\n    constructor(){\n        this.maxLogs = 1000 // Keep last 1000 log entries\n        ;\n        this.logKey = \"lm_ui_logs\";\n    }\n}\n// Export singleton instance\nconst logger = new Logger();\n// Log initialization\nlogger.info(\"Logger\", \"UI Logger initialized\", {\n    url:  true ? window.location.href : 0,\n    userAgent:  true ? navigator.userAgent : 0\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU0wQyxTQUFTLElBQUluRSxTQUFTO0FBRW5DLHFCQUFxQjtBQUNyQm1FLE9BQU9yQyxJQUFJLENBQUMsVUFBVSx5QkFBeUI7SUFDN0NjLEtBQUssS0FBa0IsR0FBY3dCLE9BQU9DLFFBQVEsQ0FBQ25CLElBQUksR0FBRztJQUM1RG9CLFdBQVcsS0FBa0IsR0FBY0MsVUFBVUQsU0FBUyxHQUFHO0FBQ25FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvbG9nZ2VyLnRzP2I0OWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEZyb250ZW5kIExvZ2dlciBVdGlsaXR5XHJcbiAqIExvZ3MgdG8gY29uc29sZSBBTkQgc2F2ZXMgdG8gbG9jYWxTdG9yYWdlIGZvciBkZWJ1Z2dpbmdcclxuICogUHJvdmlkZXMgdmVyYm9zZSBsb2dnaW5nIGZvciBhbGwgVUkgb3BlcmF0aW9uc1xyXG4gKi9cclxuXHJcbnR5cGUgTG9nTGV2ZWwgPSAnREVCVUcnIHwgJ0lORk8nIHwgJ1dBUk4nIHwgJ0VSUk9SJztcclxuXHJcbmludGVyZmFjZSBMb2dFbnRyeSB7XHJcbiAgdGltZXN0YW1wOiBzdHJpbmc7XHJcbiAgbGV2ZWw6IExvZ0xldmVsO1xyXG4gIGNhdGVnb3J5OiBzdHJpbmc7XHJcbiAgbWVzc2FnZTogc3RyaW5nO1xyXG4gIGRhdGE/OiBhbnk7XHJcbn1cclxuXHJcbmNsYXNzIExvZ2dlciB7XHJcbiAgcHJpdmF0ZSBtYXhMb2dzID0gMTAwMDsgLy8gS2VlcCBsYXN0IDEwMDAgbG9nIGVudHJpZXNcclxuICBwcml2YXRlIGxvZ0tleSA9ICdsbV91aV9sb2dzJztcclxuICBcclxuICBwcml2YXRlIGxvZyhsZXZlbDogTG9nTGV2ZWwsIGNhdGVnb3J5OiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZywgZGF0YT86IGFueSkge1xyXG4gICAgY29uc3QgZW50cnk6IExvZ0VudHJ5ID0ge1xyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgbGV2ZWwsXHJcbiAgICAgIGNhdGVnb3J5LFxyXG4gICAgICBtZXNzYWdlLFxyXG4gICAgICBkYXRhXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENvbnNvbGUgb3V0cHV0IHdpdGggY29sb3JcclxuICAgIGNvbnN0IGNvbG9ycyA9IHtcclxuICAgICAgREVCVUc6ICdcXHgxYlszNm0nLCAvLyBDeWFuXHJcbiAgICAgIElORk86ICdcXHgxYlszMm0nLCAgLy8gR3JlZW5cclxuICAgICAgV0FSTjogJ1xceDFiWzMzbScsICAvLyBZZWxsb3dcclxuICAgICAgRVJST1I6ICdcXHgxYlszMW0nICAvLyBSZWRcclxuICAgIH07XHJcbiAgICBjb25zdCByZXNldCA9ICdcXHgxYlswbSc7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICBgJHtjb2xvcnNbbGV2ZWxdfVske2xldmVsfV0ke3Jlc2V0fSBbJHtjYXRlZ29yeX1dICR7bWVzc2FnZX1gLFxyXG4gICAgICBkYXRhID8gZGF0YSA6ICcnXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBsb2dzID0gdGhpcy5nZXRMb2dzKCk7XHJcbiAgICAgICAgbG9ncy5wdXNoKGVudHJ5KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBLZWVwIG9ubHkgbGFzdCBOIGxvZ3NcclxuICAgICAgICBpZiAobG9ncy5sZW5ndGggPiB0aGlzLm1heExvZ3MpIHtcclxuICAgICAgICAgIGxvZ3Muc2hpZnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5sb2dLZXksIEpTT04uc3RyaW5naWZ5KGxvZ3MpKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBsb2c6JywgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkZWJ1ZyhjYXRlZ29yeTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcsIGRhdGE/OiBhbnkpIHtcclxuICAgIHRoaXMubG9nKCdERUJVRycsIGNhdGVnb3J5LCBtZXNzYWdlLCBkYXRhKTtcclxuICB9XHJcblxyXG4gIGluZm8oY2F0ZWdvcnk6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCBkYXRhPzogYW55KSB7XHJcbiAgICB0aGlzLmxvZygnSU5GTycsIGNhdGVnb3J5LCBtZXNzYWdlLCBkYXRhKTtcclxuICB9XHJcblxyXG4gIHdhcm4oY2F0ZWdvcnk6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCBkYXRhPzogYW55KSB7XHJcbiAgICB0aGlzLmxvZygnV0FSTicsIGNhdGVnb3J5LCBtZXNzYWdlLCBkYXRhKTtcclxuICB9XHJcblxyXG4gIGVycm9yKGNhdGVnb3J5OiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZywgZGF0YT86IGFueSkge1xyXG4gICAgdGhpcy5sb2coJ0VSUk9SJywgY2F0ZWdvcnksIG1lc3NhZ2UsIGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0IGFsbCBsb2dzIGZyb20gbG9jYWxTdG9yYWdlXHJcbiAgZ2V0TG9ncygpOiBMb2dFbnRyeVtdIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIFtdO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBsb2dzSnNvbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMubG9nS2V5KTtcclxuICAgICAgcmV0dXJuIGxvZ3NKc29uID8gSlNPTi5wYXJzZShsb2dzSnNvbikgOiBbXTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgbG9nczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENsZWFyIGFsbCBsb2dzXHJcbiAgY2xlYXJMb2dzKCkge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMubG9nS2V5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIERvd25sb2FkIGxvZ3MgYXMgZmlsZVxyXG4gIGRvd25sb2FkTG9ncygpIHtcclxuICAgIGNvbnN0IGxvZ3MgPSB0aGlzLmdldExvZ3MoKTtcclxuICAgIGNvbnN0IGxvZ1RleHQgPSBsb2dzLm1hcChlbnRyeSA9PiBcclxuICAgICAgYFske2VudHJ5LnRpbWVzdGFtcH1dIFske2VudHJ5LmxldmVsfV0gWyR7ZW50cnkuY2F0ZWdvcnl9XSAke2VudHJ5Lm1lc3NhZ2V9JHtcclxuICAgICAgICBlbnRyeS5kYXRhID8gJ1xcbiAgRGF0YTogJyArIEpTT04uc3RyaW5naWZ5KGVudHJ5LmRhdGEsIG51bGwsIDIpIDogJydcclxuICAgICAgfWBcclxuICAgICkuam9pbignXFxuXFxuJyk7XHJcblxyXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtsb2dUZXh0XSwgeyB0eXBlOiAndGV4dC9wbGFpbicgfSk7XHJcbiAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgIGEuaHJlZiA9IHVybDtcclxuICAgIGEuZG93bmxvYWQgPSBgbG0tdWktbG9ncy0ke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdfS50eHRgO1xyXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcclxuICAgIGEuY2xpY2soKTtcclxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYSk7XHJcbiAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgbG9ncyBzdW1tYXJ5XHJcbiAgZ2V0U3VtbWFyeSgpIHtcclxuICAgIGNvbnN0IGxvZ3MgPSB0aGlzLmdldExvZ3MoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvdGFsOiBsb2dzLmxlbmd0aCxcclxuICAgICAgZXJyb3JzOiBsb2dzLmZpbHRlcihsID0+IGwubGV2ZWwgPT09ICdFUlJPUicpLmxlbmd0aCxcclxuICAgICAgd2FybnM6IGxvZ3MuZmlsdGVyKGwgPT4gbC5sZXZlbCA9PT0gJ1dBUk4nKS5sZW5ndGgsXHJcbiAgICAgIGluZm86IGxvZ3MuZmlsdGVyKGwgPT4gbC5sZXZlbCA9PT0gJ0lORk8nKS5sZW5ndGgsXHJcbiAgICAgIGRlYnVnOiBsb2dzLmZpbHRlcihsID0+IGwubGV2ZWwgPT09ICdERUJVRycpLmxlbmd0aCxcclxuICAgICAgbGF0ZXN0OiBsb2dzLnNsaWNlKC0xMCkucmV2ZXJzZSgpIC8vIExhc3QgMTAgbG9nc1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcclxuZXhwb3J0IGNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoKTtcclxuXHJcbi8vIExvZyBpbml0aWFsaXphdGlvblxyXG5sb2dnZXIuaW5mbygnTG9nZ2VyJywgJ1VJIExvZ2dlciBpbml0aWFsaXplZCcsIHtcclxuICB1cmw6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmxvY2F0aW9uLmhyZWYgOiAnU1NSJyxcclxuICB1c2VyQWdlbnQ6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gbmF2aWdhdG9yLnVzZXJBZ2VudCA6ICdTU1InXHJcbn0pO1xyXG4iXSwibmFtZXMiOlsiTG9nZ2VyIiwibG9nIiwibGV2ZWwiLCJjYXRlZ29yeSIsIm1lc3NhZ2UiLCJkYXRhIiwiZW50cnkiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjb2xvcnMiLCJERUJVRyIsIklORk8iLCJXQVJOIiwiRVJST1IiLCJyZXNldCIsImNvbnNvbGUiLCJsb2dzIiwiZ2V0TG9ncyIsInB1c2giLCJsZW5ndGgiLCJtYXhMb2dzIiwic2hpZnQiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwibG9nS2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yIiwiZGVidWciLCJpbmZvIiwid2FybiIsImxvZ3NKc29uIiwiZ2V0SXRlbSIsInBhcnNlIiwiY2xlYXJMb2dzIiwicmVtb3ZlSXRlbSIsImRvd25sb2FkTG9ncyIsImxvZ1RleHQiLCJtYXAiLCJqb2luIiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiYSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImhyZWYiLCJkb3dubG9hZCIsInNwbGl0IiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJyZW1vdmVDaGlsZCIsInJldm9rZU9iamVjdFVSTCIsImdldFN1bW1hcnkiLCJ0b3RhbCIsImVycm9ycyIsImZpbHRlciIsImwiLCJ3YXJucyIsImxhdGVzdCIsInNsaWNlIiwicmV2ZXJzZSIsImxvZ2dlciIsIndpbmRvdyIsImxvY2F0aW9uIiwidXNlckFnZW50IiwibmF2aWdhdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/logger.ts\n"));

/***/ })

});